# 切片

## 问题一

给定 `s := make([]byte, 5)`，len (s) 和 cap (s) 分别是多少？`s = s[2:4]`，len (s) 和 cap (s) 又分别是多少？

```go
package main

import "fmt"

func main() {
	s := make([]byte, 5)
	fmt.Println("切片 s 的长度：", len(s), "，切片 s 的容量：", cap(s))
	s = s[2:4]
	fmt.Println("切片 s 的长度：", len(s), "，切片 s 的容量：", cap(s))
}
```

```bash
切片 s 的长度： 5 ，切片 s 的容量： 5
切片 s 的长度： 2 ，切片 s 的容量： 3
```

## 问题二

给定切片 sl，将一个 `[]byte` 数组追加到 sl 后面。写一个函数 `Append(slice, data []byte) []byte`，该函数在 sl 不能存储更多数据的时候自动扩容。

分析：这道题本质是手动实现 go 的内建方法 [Append](https://pkg.go.dev/builtin@go1.17.2#append)，Append 就是专门进行切片内容追加的。理论上我们应该通过查看 Append 的源码来进行学习，但是 Append 是在编译阶段，由编译器实现的，在 builtin.go 下只能看到定义，所以我们只能靠猜测来进行实现。具体原因可以参考[一文告诉你神奇的Go内建函数源码在哪里](https://tonybai.com/2020/12/17/where-is-the-source-of-builtin-functions/)，[Go语言基础：make，new, len, cap, append, delete方法](https://blog.csdn.net/jfkidear/article/details/87721494)这两篇文章。



下面的答案是我根据自己的理解进行了一个简单的实现，当然这不是一个完整像 go 原生实现的 Append 方法。

```go
package main

import "fmt"

func main() {
	sliceFirst := []byte{1, 2}
	appendData := []byte{3, 4, 5}

	ans := Append(sliceFirst, appendData)

	fmt.Println(ans)
}

func Append(slf, data []byte) []byte {
	// 如果传入的 sliceFirst 容量小于它本身的长度加上data的长度
	// 就扩容
	if cap(slf) < len(slf)+len(data) {
		// 这里我采用将元素长度求和的方式扩容 cap
		slflen := len(slf) + len(data)
		// 创建一个新 slice，其len=cap=slflen
		newSlice := make([]byte, slflen)
		// 先将原来的 sliceFirst 的内容放入 newSlice
		for i := 0; i < len(slf); i++ {
			newSlice[i] = slf[i]
		}
		// 然后将追加元素也放进去
		for i, j := len(slf), 0; i < len(data)+len(slf); i, j = i+1, j+1 {
			newSlice[i] = data[j]
		}
		return newSlice
	} else {
		// 如果 sliceFirst 长度足够
		for i := len(slf) - 1; i < cap(slf); i++ {
			slf[i] = data[i]
		}
		return slf
	}
}
```

```bash
[1 2 3 4 5]
```

